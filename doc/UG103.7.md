# **UG103.7：Non-Volatile Data Storage Fundamentals** <!-- omit in toc -->

本文档提供了使用闪存的非易失性数据存储的一般介绍，重点介绍了为 Silicon Labs 微控制器和无线 SoC（片上系统）提供的三种不同的动态数据存储实现。它提供了三种实现的比较，并提供了何时使用哪种实现的建议。有关使用各种数据存储实现的更多详细信息，请参阅以下文档：
* **AN1154: Using Tokens for Non-Volatile Data Storage**
* **AN703: Using Simulated EEPROM Version 1 and Version 2 for the EM35x and EFR32 SoC Platforms**
* **AN1135: Using Third Generation Non-Volatile Memory (NVM3) Data Storage in Dynamic Multiprotocol Applications**

Silicon Labs 的基础系列涵盖了项目经理，应用程序设计人员和开发人员在开始使用 Silicon Labs 芯片，EmberZNet PRO 或 Silicon Labs Bluetooth Smart 等网络栈以及相关开发工具的嵌入式网络解决方案之前应该了解的主题。这些文档可以作为任何需要介绍开发无线网络应用程序的人或者是 Silicon Labs 开发环境的新手的起点。

关键点：
* 审查实现非易失性数据存储的挑战和设计选项。
* 审查三种动态数据存储实现。
* 令牌和令牌 API 简介。
* 三种动态数据存储实现的比较。

------------------------------------------------------------------------------------------------------------------------

- [**1. 引言**](#1-引言)
- [**2. 非易失性数据存储的实现**](#2-非易失性数据存储的实现)
    - [**2.1 基本实现**](#21-基本实现)
    - [**2.2 处理复位和电源故障**](#22-处理复位和电源故障)
    - [**2.3 引入虚拟页**](#23-引入虚拟页)
    - [**2.4 基本存储**](#24-基本存储)
    - [**2.5 FIFO 模型**](#25-fifo-模型)
    - [**2.6 计数器对象**](#26-计数器对象)
    - [**2.7 索引对象**](#27-索引对象)
- [**3. 动态数据存储实现**](#3-动态数据存储实现)
    - [**3.1 SimEEv1/v2**](#31-simeev1v2)
    - [**3.2 PS Store**](#32-ps-store)
    - [**3.3 NVM3**](#33-nvm3)
- [**4. 令牌和令牌 API**](#4-令牌和令牌-api)
- [**5. 非易失性数据存储实现的比较**](#5-非易失性数据存储实现的比较)
    - [**5.1 闪存寿命**](#51-闪存寿命)
        - [**5.1.1 闪存寿命估算**](#511-闪存寿命估算)

------------------------------------------------------------------------------------------------------------------------

# **1. 引言**

非易失性存储器（NVM）是一种即使设备重启仍然存在的存储器。在 Silicon Labs 微控制器和无线电 SoC 上，NVM 由闪存实现。在许多应用程序中，闪存不仅用于存储应用程序代码，还用于存储应用程序频繁读写的数据对象。由于闪存擦除的次数有限，因此存在多种方法来有效地读写非易失性数据而不会磨损闪存。

某些数据被认为是在制造时仅写入一次的制造数据。本文档关注的是在产品生命周期内频繁更改的动态数据。

本文档介绍了微控制器和无线电 SoC 中动态数据存储的主要设计选项，以及影响闪存寿命的因素。此外，它还介绍了 Silicon Labs 提供的主要闪存数据存储实现：
* NVM3
* 模拟 EEPROM v1（SimEEv1）和 v2（SimEEv2）
* 持久化存储（PS Store）

------------------------------------------------------------------------------------------------------------------------

# **2. 非易失性数据存储的实现**

本章介绍了在闪存中实现非易失性数据存储时的一些挑战和设计选项。它高度描述了如何在 PS Store，SimEEv1/v2 和 NVM3 的闪存中实现非易失性数据存储。

## **2.1 基本实现**

闪存的一个特征是它可以写在较小的块中，通常是 32 位字，而它只能以较大的块（通常是几千字节的页）擦除。使用闪存作为数据存储时，最直接的实现选项是将每个数据对象存储在自己的闪存页中，如下图所示。这样，每个对象都可以被擦除和重写，而不会影响其他数据对象。通常，数据对象比页大小小得多，并且此解决方案不是使用可用闪存空间的有效方法。

![Figure 2.1. One Object Per Page](../pic/UG103.7-F2.1.jpg)

为了避免浪费闪存空间，我们可以在一个闪存页中存储多个数据对象，如下图所示。当我们想要将一个新值写入其中的一个数据对象时，该解决方案会引入一个挑战。在这种情况下，必须先擦除页，然后再将所有对象写回页，包括我们更改的对象。由于闪存在闪存单元磨损之前只能承受有限数量的闪存擦除，因此该解决方案导致设备寿命非常有限。

![Figure 2.2. Multiple Objects in One Flash Page](../pic/UG103.7-F2.2.jpg)

为了避免为每个对象的写入擦除闪存页，我们可以将每个对象的新版本写入到闪存页的新的空位置中。这是一种简单的耗损均衡形式，可减少页擦除次数。然而，这要求我们存储一些标识信息以及告诉我们数据属于哪个对象的对象数据，这样我们就知道如何找到数据对象的最新版本。如下图所示，在每个版本的对象数据中都添加一个键的来标识数据属于哪个对象。当访问对象时，我们需要在闪存页中搜索该对象的最新版本。在这种情况下，最新版本是具有最高地址的版本，因为我们从页的最低地址开始写入。

![Figure 2.3. Object Versions With Keys](../pic/UG103.7-F2.3.jpg)

## **2.2 处理复位和电源故障**

由于我们用新版本的数据对象填充闪存页，最终将没有空间来写入新的对象数据。此时我们需要擦除页并重新开始，只将每个对象的最新版本写回闪存页。然而，在许多应用中，电源故障或复位可能随时发生，如果发生这种情况，我们不应该冒丢失数据的风险。如果在擦除闪存页之后，写回数据对象之前发生复位，那么我们将丢失此数据。为了处理这种情况，我们在删除原始页之前引入第二页，并将数据对象的最新版本复制到该页，如下图所示。然后我们可以开始用数据填充第二页。当第二页已满时，我们将最新数据移回第一页，依此类推。这种机制，即存储在两个闪存页之间交替，这就是 PS Store 的操作方式。

![Figure 2.4. Latest Data Copied to New Page Before Erase](../pic/UG103.7-F2.4.jpg)

## **2.3 引入虚拟页**

在某些应用程序中，我们频繁地写入数据对象，因此也需要频繁地擦除闪存页。由于到目前为止实现中的数据对象仅分布在两个闪存页上，因此每个页将频繁地被擦除并且闪存寿命将受到限制。为了延长使用寿命，我们可以使用更多的闪存页来存储数据对象。在本例中，我们使用两个虚拟页（A 和 B）进行操作，每个虚拟页由多个物理闪存页组成。虚拟页被擦除并写入，就像它们是一个较大的闪存页一样。不同之处在于每个虚拟页都更大，我们可以在需要擦除虚拟页之前写入更多数据，从而延长了寿命。除了增加闪存寿命外，每个虚拟页使用多个闪存页还可以存储更多或更大的对象。SimEEv1 使用此设计，每个虚拟页由两个闪存页（A 和 B）组成，如下图所示。

![Figure 2.5. Virtual Pages](../pic/UG103.7-F2.5.jpg)

在某些应用中，必须最小化写入非易失性数据对象所花费的时间，以免干扰其他关键操作的时序。如果在虚拟页已满时触发了对象写入，则必须先将所有对象的最新版本复制到新的虚拟页，然后再将相关新对象版本写入到新页。必须立即复制所有对象以便快速擦除第一页，这样我们就可以在发生故障时将数据迁移到那里。一次复制所有对象会增加最坏情况下的对象写入时间。

为了减少写入时间，可以引入始终保持擦除的第三个虚拟页。当第一页已满时，我们可以只复制一些对象，而不是复制每个对象的最新版本。其余的对象将作为后续写入操作的一部分进行复制。这样，我们通过更多的写操作将复制过程扩展到新页，因此每次写操作只需要较少的时间来完成。通过这种方法，我们将实时对象数据分布在两个虚拟页上，并且第三页始终保持擦除，因此我们可以在发生故障时将数据迁移到某处。SimEEv2 将使用此带有 3 个虚拟页的实现，其中每个虚拟页由 6 个闪存页组成。

## **2.4 基本存储**

基本存储定义为所有对象的所有最新版本的大小，包括与它们一起存储的任何开销。每次擦除闪存页或虚拟页时，我们必须先将基本存储迁移到新页。基本存储大小很重要，因为它决定了在页中保留多少闪存空间来存储对象数据的任何新版本。如果基本存储占用了几乎整个页，那么在我们需要迁移到新页并擦除旧页之前，我们只能写入很少的对象版本。这会导致频繁的页擦除和短暂的闪存寿命。

## **2.5 FIFO 模型**

闪存数据存储实现可以建模为一个先进先出（FIFO）缓冲区（见下图），其中我们向 FIFO 的输入写入新版本。当 FIFO 填满时，我们需要通过擦除 FIFO 末尾的一个或多个页来释放空间。在擦除页之前，我们需要复制其他闪存页中没有相同对象的较新版本的任何对象版本。可以丢弃其他对象数据，因为存在更新的版本。为了最大化闪存寿命，我们希望尽可能少地复制对象版本，以便大多数对闪存的写入都是对象的新版本。如果 FIFO 是在一个大的闪存空间上实现的，则更有可能是已经写入了对象的新版本，并且可以丢弃 FIFO 末尾的对象版本。在这种情况下，可以在很少或没有复制对象版本的情况下擦除闪存页。

![Figure 2.6. FIFO Buffer](../pic/UG103.7-F2.6.jpg)

使用少量虚拟页的缺点是 FIFO 的可用内存仅限于可以保存实时数据的虚拟页。对于使用两个虚拟页（如 SimEEv1）的实现，这意味着只有一半的存储空间用于 FIFO，而对于 SimEEv2，三分之二的存储空间可用于 FIFO。

为了允许更高比例的存储空间用于 FIFO，我们可以在分配的整个闪存存储空间上将 FIFO 实现为循环缓冲区，如下图所示。在此实现中，我们总是需要在缓冲区的前沿保留足够的已擦除页，以便在发生故障时写入最大的对象。当 FIFO 填充到要擦除闪存页的临界数量时，我们会复制任何尚未被取代的对象版本并擦除 FIFO 后面的页。这意味着，我们只需要保留足够的空间以适应最大的对象，而不是保留完整的虚拟页。我们可以将余下的空间用于 FIFO。NVM3 在整个存储空间上实现为一个循环缓冲区实现，因此与使用较小虚拟页的实现相比，增加了闪存寿命。

![Figure 2.7. Circular Buffer](../pic/UG103.7-F2.7.jpg)

## **2.6 计数器对象**

对于某些类型的数据，可以针对闪存介质优化存储格式。例如，计数器值通常在每次写入时递增 1 或其他一些低值。通常这意味着每次计数器递增时，除了标识字节之外，我们还必须写入整个计数器值。我们可以通过仅在第一次写入计数器时存储除标识值之外的起始值来优化这一点。然后，我们在写入增量的初始值之后保留一些字，以便写入增量。由于 Silicon Labs 设备中的闪存字可以为每次擦除写入两次，因此可以为每个增量使用一个半字。然后通过将增量值写入到一个半字来写入一个增量。为了找到当前计数器值，我们从初始值开始，并在初始值后面的半字中添加增量值。这意味着我们只需要为每个增量写入一个半字，而不是整个计数器值和标识值。NVM3 和 SimEEv1/v2 支持计数器对象。

## **2.7 索引对象**

在闪存中存储数组等数据时，我们通常一次只更新一个索引。如果我们将整个数组存储为一个常规对象，那么即使只更新了一个索引，我们也必须将整个数组写入闪存。我们可以将每个数据数组分配到多个对象上，而不是将整个数组存储在一个对象中，而只更新包含更改的数组索引的对象。虽然可以为所有 Silicon Labs 存储实现手动将数组拆分为多个对象，但 SimEEv1/v2 允许所有索引共享一个对象键。然后，将要查找的数组中的索引条目作为单独的参数提供。

------------------------------------------------------------------------------------------------------------------------

# **3. 动态数据存储实现**

本章介绍 Silicon Labs 提供的一些动态数据存储实现，包括 SimEEv1 和 SimEEv2，PS Store 和 NVM3。

## **3.1 SimEEv1/v2**

SimEEv1/v2 与 EmberZNet PRO、Silicon Labs Thread 和 Flex SDK 以及一些多协议应用程序一起使用。SimEEv1 使用两个固定的总大小为 8 kB 的虚拟页，而 SimEEv2 使用三个固定的总大小为 36 kB 的虚拟页。

SimEEv1/v2 的一个特征是在编译时使用大小和类型定义所有对象，因此无法在运行时创建或删除新对象。

Silicon Labs 提供了一个用于将 SimEEv1 数据升级到 SimEEv2 的插件。

有关 SimEEv1/v2 实现的信息可在 **AN703：Using Simulated EEPROM Version 1 and Version 2 for the EM35x and EFR32 SoC Platforms** 中找到。

## **3.2 PS Store**

PS Store 与蓝牙设备一起使用。PS Store API 命令用于管理蓝牙设备闪存中的 PS 键中的用户数据。存储在闪存中的用户数据在设备的复位和重启期间是持久的。持久存储大小为 2048 字节，并使用两个闪存页进行存储。由于蓝牙绑定也存储在此区域中，因此可用于用户数据的空间还取决于设备当时的绑定数量。一个蓝牙绑定的大小约为 150 字节。凭借其简单的实现和少量的存储闪存页，PS Store 是 Silicon Labs 中最小的非易失性存储选项。PS Store 允许在运行时创建和删除对象。

有关 PS Store API 的信息可在 **Bluetooth API Software Reference Manual** 中找到。

## **3.3 NVM3**

第三代非易失性存储器（NVM3）数据存储驱动程序是 SimEEv1/v2 和 PS Store 的替代品。NVM3 驱动程序提供了一种方法，以读写存储在闪存中的数据对象（键/值 对）。应用损耗均衡以减少擦除和写入周期并最大化闪存寿命。驱动程序对断电和复位事件具有弹性，确保了从驱动程序检索的对象始终处于有效状态。由于 NVM3 可以与蓝牙和 EmberZNet PRO 一起使用，因此它允许在动态多协议（DMP）应用程序中共享单个数据存储实例。

NVM3 的一些主要特性如下：
* 闪存中的 键/值 对数据存储
* 运行时创建和删除对象
* 在断电和复位事件中保持持久性
* 磨损均衡可最大限度地延长闪存寿命
* 对象大小范围为 0 到 1900 字节
* 可配置的闪存大小（最少 3 个闪存页）
* 具有可配置大小的缓存，以便快速访问对象
* 数据和计数器对象类型
* 提供了令牌和 PS Store API 的兼容层
* 多协议应用程序中的单个共享存储实例
* 重新包装 API，允许应用程序在 CPU 负载较低的时段运行清除页的擦除

有关 NVM3 的详细信息，请参阅 **Gecko HAL & Driver API Reference Guide** 的 EMDRV->NVM3 部分。通过其本地 API 访问 NVM3 的用户应参阅此 API 参考指南以获取信息。正在开发动态多协议应用程序的用户应参考 **AN1135：Using Third Generation Non-Volatile Memory (NVM3) Data Storage in Dynamic Multiprotocol Applications**。

------------------------------------------------------------------------------------------------------------------------

# **4. 令牌和令牌 API**

令牌（Token）是一种抽象的数据常量，对应用程序具有特殊的持久含义，用于存储数据对象，如 [2. 非易失性数据存储的实现](#2-非易失性数据存储的实现) 中所述。令牌有两部分：令牌键和令牌数据。令牌键是用于存储和检索令牌数据的唯一标识符。在许多情况下，“令牌” 一词的使用非常宽松地表示为令牌键，令牌数据或键和数据的结合。在此文档中，令牌始终引用为 键 + 数据 对。

令牌系统的基本目的是允许令牌数据在重启和断电期间持续存在。通过使用令牌键来标识适当的数据，请求令牌数据的应用程序不需要知道数据的存储位置。这简化了应用程序设计和代码重用。

有两种类型的动态令牌：
* 非索引（或基本）令牌
* 索引令牌

动态令牌也可以根据其软件目的在以下组中进行分类：
* 栈令牌：这些令牌是可 读/写 的，并在每个应用程序中定义，以支持栈行为。这些令牌位于 NVM3 或 SimEEv1/v2 中。
* 应用令牌：这些令牌是可 读/写 的，并由应用程序定义，以支持应用程序行为。客户可以决定是否有应用令牌，其如何定义的以及其作用。这些令牌位于 NVM3 或 SimEEv1/v2 中。

令牌 API 是一个包装函数和宏的集合，用于定义和访问 EmberZNet PRO，Silicon Labs Thread 和 Flex SDK 中的非易失性数据对象，以及一些多协议应用程序。

有关令牌类型，分组以及有关如何定义和访问令牌的更多信息，请参阅 **AN1154：Using Tokens for Non-Volatile Data Storage**。用户应在使用令牌 API 之前阅读此文档。有关令牌 API 的信息在栈 API 参考的 HAL API 部分中提供。

------------------------------------------------------------------------------------------------------------------------

# **5. 非易失性数据存储实现的比较**

下表概述了各种 Silicon Labs 非易失性数据存储实现的主要特性。

![Table 5.1. NV Data Storage Implementation Comparison](../pic/UG103.7-T5.1.jpg)

## **5.1 闪存寿命**

所有 Silicon Labs 闪存数据存储实现都使用某种形式的耗损均衡来延长闪存寿命。耗损均衡的有效性取决于实现，存储的数据类型以及更新的频率。影响磨损和闪存寿命的主要因素是：
* 用于数据存储的闪存大小：闪存区域越多，闪存寿命越长。对于 NVM3，可以配置用于数据存储的闪存页数，而其余实现使用固定存储大小。
* 每个对象存储的开销：将数据写入对象存储时，会添加一些开销字节以标识数据。较少开销的实现意味着数据对象在闪存中占用较少的空间，并提供更长的闪存寿命。
* 对齐到最小对象大小：对象以最小对象大小的倍数存储。如果数据大小与此大小不对齐，则会添加填充字节，这会增加存储的数据并缩短闪存生命周期。例如，当存储 16 位令牌时，除了开销字节之外，NVM3 和 PS 存储还添加两个额外的填充字节。SimEEv1/v2 能够存储 16 位数据对象而无需填充。
* 基本存储后的剩余存储：对于使用虚拟页的实现，当切换到新的虚拟页时，每个对象的一个​​实例将写入页。然后，可以使用虚拟页的其余部分来存储对象的新写入。如果使用大量空间来存储每个对象的一个​​实例，则在虚拟页中留下很少的空间用于对后续对象写入进行耗损均衡。因此，当对象数据的总量相对于虚拟页大小较大时，闪存寿命将减少。即使对于未使用虚拟页的 NVM3，闪存寿命也受到整个 NVM3 存储空间的可用空间的限制。

为了帮助监控实际的闪存磨损，NVM3 和 SimEEv1/v2 包括了用于报告数据存储闪存页面的页面擦除次数的函数调用。在产品的加速寿命测试期间可以读取这些擦除计数器，以验证闪存是否以可接受的速率磨损。

### **5.1.1 闪存寿命估算**

一个可用于估算应用程序闪存寿命的工具，通过 Microsoft Excel 电子表格（**ug103-07s-token-lifetime-estimator-efr32-series1.xls**）获得。要创建估算，必须在电子表格中输入一组 对象/令牌，并估算这些对象在应用程序中的写入频率。电子表格将计算使用 NVM3，PS Store 和 SimEEv1/v2 时设备的预估闪存寿命。有关如何使用估算器的更多信息，请参阅电子表格的 **README**。

> Note：电子表格仅使用理想的存储实现模型进行估算。应用程序的实际闪存寿命可能不同。

------------------------------------------------------------------------------------------------------------------------
