# **UG103.7：Non-Volatile Data Storage Fundamentals** <!-- omit in toc -->

本文档提供了使用闪存的非易失性数据存储的一般介绍，重点介绍了为 Silicon Labs 微控制器和无线 SoC（片上系统）提供的三种不同的动态数据存储实现。它提供了三种实现的比较，并提供了何时使用哪种实现的建议。有关使用各种数据存储实现的更多详细信息，请参阅以下文档：
* **AN1154: Using Tokens for Non-Volatile Data Storage**
* **AN703: Using Simulated EEPROM Version 1 and Version 2 for the EM35x and EFR32 SoC Platforms**
* **AN1135: Using Third Generation Non-Volatile Memory (NVM3) Data Storage in Dynamic Multiprotocol Applications**

Silicon Labs 的基础系列涵盖了项目经理，应用程序设计人员和开发人员在开始使用 Silicon Labs 芯片，EmberZNet PRO 或 Silicon Labs Bluetooth Smart 等网络栈以及相关开发工具的嵌入式网络解决方案之前应该了解的主题。这些文档可以作为任何需要介绍开发无线网络应用程序的人或者是 Silicon Labs 开发环境的新手的起点。

关键点：
* 审查实现非易失性数据存储的挑战和设计选项。
* 审查三种动态数据存储实现。
* 令牌和令牌 API 简介。
* 三种动态数据存储实现的比较。

------------------------------------------------------------------------------------------------------------------------

- [**1. 引言**](#1-引言)
- [**2. 非易失性数据存储的实现**](#2-非易失性数据存储的实现)
    - [**2.1 基本实现**](#21-基本实现)
    - [**2.2 处理复位和电源故障**](#22-处理复位和电源故障)
    - [**2.3 引入虚拟页**](#23-引入虚拟页)
    - [**2.4 基本存储**](#24-基本存储)
    - [**2.5 FIFO 模型**](#25-fifo-模型)
    - [**2.6 计数器对象**](#26-计数器对象)
    - [**2.7 索引对象**](#27-索引对象)

------------------------------------------------------------------------------------------------------------------------

# **1. 引言**

非易失性存储器（NVM）是一种即使设备重启仍然存在的存储器。在 Silicon Labs 微控制器和无线电 SoC 上，NVM 由闪存实现。在许多应用程序中，闪存不仅用于存储应用程序代码，还用于存储应用程序频繁读写的数据对象。由于闪存擦除的次数有限，因此存在多种方法来有效地读写非易失性数据而不会磨损闪存。

某些数据被认为是在制造时仅写入一次的制造数据。本文档关注的是在产品生命周期内频繁更改的动态数据。

本文档介绍了微控制器和无线电 SoC 中动态数据存储的主要设计选项，以及影响闪存寿命的因素。此外，它还介绍了 Silicon Labs 提供的主要闪存数据存储实现：
* NVM3
* 模拟 EEPROM v1（SimEEv1）和 v2（SimEEv2）
* 持久化存储（PS Store）

------------------------------------------------------------------------------------------------------------------------

# **2. 非易失性数据存储的实现**

本章介绍了在闪存中实现非易失性数据存储时的一些挑战和设计选项。它高度描述了如何在 PS Store，SimEEv1/v2 和 NVM3 的闪存中实现非易失性数据存储。

## **2.1 基本实现**

闪存的一个特征是它可以写在较小的块中，通常是 32 位字，而它只能以较大的块（通常是几千字节的页）擦除。使用闪存作为数据存储时，最直接的实现选项是将每个数据对象存储在自己的闪存页中，如下图所示。这样，每个对象都可以被擦除和重写，而不会影响其他数据对象。通常，数据对象比页大小小得多，并且此解决方案不是使用可用闪存空间的有效方法。

![Figure 2.1. One Object Per Page](../pic/UG103.7-F2.1.jpg)

为了避免浪费闪存空间，我们可以在一个闪存页中存储多个数据对象，如下图所示。当我们想要将一个新值写入其中的一个数据对象时，该解决方案会引入一个挑战。在这种情况下，必须先擦除页，然后再将所有对象写回页，包括我们更改的对象。由于闪存在闪存单元磨损之前只能承受有限数量的闪存擦除，因此该解决方案导致设备寿命非常有限。

![Figure 2.2. Multiple Objects in One Flash Page](../pic/UG103.7-F2.2.jpg)

为了避免为每个对象的写入擦除闪存页，我们可以将每个对象的新版本写入到闪存页的新的空位置中。这是一种简单的耗损均衡形式，可减少页擦除次数。然而，这要求我们存储一些标识信息以及告诉我们数据属于哪个对象的对象数据，这样我们就知道如何找到数据对象的最新版本。如下图所示，在每个版本的对象数据中都添加一个键的来标识数据属于哪个对象。当访问对象时，我们需要在闪存页中搜索该对象的最新版本。在这种情况下，最新版本是具有最高地址的版本，因为我们从页的最低地址开始写入。

![Figure 2.3. Object Versions With Keys](../pic/UG103.7-F2.3.jpg)

## **2.2 处理复位和电源故障**

由于我们用新版本的数据对象填充闪存页，最终将没有空间来写入新的对象数据。此时我们需要擦除页并重新开始，只将每个对象的最新版本写回闪存页。然而，在许多应用中，电源故障或复位可能随时发生，如果发生这种情况，我们不应该冒丢失数据的风险。如果在擦除闪存页之后，写回数据对象之前发生复位，那么我们将丢失此数据。为了处理这种情况，我们在删除原始页之前引入第二页，并将数据对象的最新版本复制到该页，如下图所示。然后我们可以开始用数据填充第二页。当第二页已满时，我们将最新数据移回第一页，依此类推。这种机制，即存储在两个闪存页之间交替，这就是 PS Store 的操作方式。

![Figure 2.4. Latest Data Copied to New Page Before Erase](../pic/UG103.7-F2.4.jpg)

## **2.3 引入虚拟页**

在某些应用程序中，我们频繁地写入数据对象，因此也需要频繁地擦除闪存页。由于到目前为止实现中的数据对象仅分布在两个闪存页上，因此每个页将频繁地被擦除并且闪存寿命将受到限制。为了延长使用寿命，我们可以使用更多的闪存页来存储数据对象。在本例中，我们使用两个虚拟页（A 和 B）进行操作，每个虚拟页由多个物理闪存页组成。虚拟页被擦除并写入，就像它们是一个较大的闪存页一样。不同之处在于每个虚拟页都更大，我们可以在需要擦除虚拟页之前写入更多数据，从而延长了寿命。除了增加闪存寿命外，每个虚拟页使用多个闪存页还可以存储更多或更大的对象。SimEEv1 使用此设计，每个虚拟页由两个闪存页（A 和 B）组成，如下图所示。

![Figure 2.5. Virtual Pages](../pic/UG103.7-F2.5.jpg)

在某些应用中，必须最小化写入非易失性数据对象所花费的时间，以免干扰其他关键操作的时序。如果在虚拟页已满时触发了对象写入，则必须先将所有对象的最新版本复制到新的虚拟页，然后再将相关新对象版本写入到新页。必须立即复制所有对象以便快速擦除第一页，这样我们就可以在发生故障时将数据迁移到那里。一次复制所有对象会增加最坏情况下的对象写入时间。

为了减少写入时间，可以引入始终保持擦除的第三个虚拟页。当第一页已满时，我们可以只复制一些对象，而不是复制每个对象的最新版本。其余的对象将作为后续写入操作的一部分进行复制。这样，我们通过更多的写操作将复制过程扩展到新页，因此每次写操作只需要较少的时间来完成。通过这种方法，我们将实时对象数据分布在两个虚拟页上，并且第三页始终保持擦除，因此我们可以在发生故障时将数据迁移到某处。SimEEv2 将使用此带有 3 个虚拟页的实现，其中每个虚拟页由 6 个闪存页组成。

## **2.4 基本存储**

基本存储定义为所有对象的所有最新版本的大小，包括与它们一起存储的任何开销。每次擦除闪存页或虚拟页时，我们必须先将基本存储迁移到新页。基本存储大小很重要，因为它决定了在页中保留多少闪存空间来存储对象数据的任何新版本。如果基本存储占用了几乎整个页，那么在我们需要迁移到新页并擦除旧页之前，我们只能写入很少的对象版本。这会导致频繁的页擦除和短暂的闪存寿命。

## **2.5 FIFO 模型**

闪存数据存储实现可以建模为一个先进先出（FIFO）缓冲区（见下图），其中我们向 FIFO 的输入写入新版本。当 FIFO 填满时，我们需要通过擦除 FIFO 末尾的一个或多个页来释放空间。在擦除页之前，我们需要复制其他闪存页中没有相同对象的较新版本的任何对象版本。可以丢弃其他对象数据，因为存在更新的版本。为了最大化闪存寿命，我们希望尽可能少地复制对象版本，以便大多数对闪存的写入都是对象的新版本。如果 FIFO 是在一个大的闪存空间上实现的，则更有可能是已经写入了对象的新版本，并且可以丢弃 FIFO 末尾的对象版本。在这种情况下，可以在很少或没有复制对象版本的情况下擦除闪存页。

![Figure 2.6. FIFO Buffer](../pic/UG103.7-F2.6.jpg)

使用少量虚拟页的缺点是 FIFO 的可用内存仅限于可以保存实时数据的虚拟页。对于使用两个虚拟页（如 SimEEv1）的实现，这意味着只有一半的存储空间用于 FIFO，而对于 SimEEv2，三分之二的存储空间可用于 FIFO。

为了允许更高比例的存储空间用于 FIFO，我们可以在分配的整个闪存存储空间上将 FIFO 实现为循环缓冲区，如下图所示。在此实现中，我们总是需要在缓冲区的前沿保留足够的已擦除页，以便在发生故障时写入最大的对象。当 FIFO 填充到要擦除闪存页的临界数量时，我们会复制任何尚未被取代的对象版本并擦除 FIFO 后面的页。这意味着，我们只需要保留足够的空间以适应最大的对象，而不是保留完整的虚拟页。我们可以将余下的空间用于 FIFO。NVM3 在整个存储空间上实现为一个循环缓冲区实现，因此与使用较小虚拟页的实现相比，增加了闪存寿命。

![Figure 2.7. Circular Buffer](../pic/UG103.7-F2.7.jpg)

## **2.6 计数器对象**

对于某些类型的数据，可以针对闪存介质优化存储格式。例如，计数器值通常在每次写入时递增 1 或其他一些低值。通常这意味着每次计数器递增时，除了标识字节之外，我们还必须写入整个计数器值。我们可以通过仅在第一次写入计数器时存储除标识值之外的起始值来优化这一点。然后，我们在写入增量的初始值之后保留一些字，以便写入增量。由于 Silicon Labs 设备中的闪存字可以为每次擦除写入两次，因此可以为每个增量使用一个半字。然后通过将增量值写入到一个半字来写入一个增量。为了找到当前计数器值，我们从初始值开始，并在初始值后面的半字中添加增量值。这意味着我们只需要为每个增量写入一个半字，而不是整个计数器值和标识值。NVM3 和 SimEEv1/v2 支持计数器对象。

## **2.7 索引对象**

在闪存中存储数组等数据时，我们通常一次只更新一个索引。如果我们将整个数组存储为一个常规对象，那么即使只更新了一个索引，我们也必须将整个数组写入闪存。我们可以将每个数据数组分配到多个对象上，而不是将整个数组存储在一个对象中，而只更新包含更改的数组索引的对象。虽然可以为所有 Silicon Labs 存储实现手动将数组拆分为多个对象，但 SimEEv1/v2 允许所有索引共享一个对象键。然后，将要查找的数组中的索引条目作为单独的参数提供。

------------------------------------------------------------------------------------------------------------------------

